#!/usr/bin/env python3

import os
import argparse
import sys
import json
import tkinter as tk
import traceback
import subprocess
import tkinter.messagebox
import time


def do_autotype(gui, filter, entry):
    """
    Auto type value into the currently focusses window.
    """
    from pynput.keyboard import Key, Controller
    gui.win_hide()
    keyboard = Controller()
    keyboard.type(entry['value'])
    time.sleep(0.2)
    keyboard.press(Key.enter)
    time.sleep(0.2)
    keyboard.release(Key.enter)
    time.sleep(0.2)
    gui.quit()

def do_browser(gui, filter, entry):
    """
    Open value in browser. {q} is replaced with the filter typed by the user.
    """
    import webbrowser
    url = entry["value"].format(filter=filter)
    webbrowser.open_new_tab(url)
    gui.quit()

def do_exec(gui, filter, entry):
    """
    Execute value as a command. Optionally capture the output and show it in
    the console.
    """
    # If we need to capture output of the command, do so. Otherwise, just run
    # it.
    if (entry.get("output_win", False) is True or
        entry.get("output_inline", False) is True):
        p = subprocess.Popen(
            entry["value"].replace('{filter}', filter),
            shell=entry.get("shell", False),
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT
        )
        output = p.communicate()[0]
    else:
        p = subprocess.Popen(
            entry["value"].replace('{filter}', filter),
            shell=entry.get("shell", False),
        )

    # Clear filter typed by user
    if entry.get('clear_input', True) is True:
        gui.filter_value.set("")

    # Display command output in seperate window, or in the inline console.
    if entry.get('output_win', False) is True:
        msg(output)
    elif entry.get('output_inline', False) is True:
        gui.append_console_output(output)
        # Do not quit the main gui
        return

    gui.quit()

def do_totp(gui, filter, entry):
    """
    Generate TOTP / rfc6238 / two-factor / Google Authenticator authentication
    codes, and autotype them.
    """
    import pyotp
    from pynput.keyboard import Key, Controller
    totp = pyotp.TOTP(entry["value"])
    code = totp.now()
    gui.win_hide()
    keyboard = Controller()
    keyboard.type(code)
    gui.quit()


do_mapper = {
    "autotype": do_autotype,
    "browser": do_browser,
    "exec": do_exec,
    "totp": do_totp,
}


def msg(value):
    """
    Show a popup message window with a 'console'.
    """
    root = tkinter.Tk()
    root.title("Output")
    def quiet():
        sys.exit(0)
    text = tkinter.Text(root, height=25, width=80, bg="black", fg="white", relief=tkinter.FLAT)
    text.insert(tkinter.END, value)
    scrollbar = tkinter.Scrollbar(root)
    scrollbar.pack(side=tkinter.RIGHT, fill=tkinter.Y)
    scrollbar.config(command=text.yview)
    text.pack(side=tkinter.LEFT, fill=tkinter.BOTH, expand=tkinter.YES)
    text.config(yscrollcommand=scrollbar.set)
    root.bind("<Escape>", quit)
    tkinter.mainloop()


class AutoScrollbar(tkinter.Scrollbar):
    # a scrollbar that hides itself if it's not needed.  only
    # works if you use the grid geometry manager.
    def set(self, lo, hi):
        if float(lo) <= 0.0 and float(hi) >= 1.0:
            # grid_remove is currently missing from Tkinter!
            self.tk.call("grid", "remove", self)
        else:
            self.grid()
        tkinter.Scrollbar.set(self, lo, hi)


class GUI:
    """
    Main Lurch GUI.
    """
    def __init__(self, width, height, console_lines, entries):
        self.width = width
        self.height = height
        self.console_lines = console_lines
        self.entries = entries
        self.visible = False
        self.cur_entries = entries

        self.root = tkinter.Tk()
        self.root.title("Lurch - You rang?")
        imgicon = tkinter.PhotoImage(file=self._get_icon_path())
        self.root.tk.call('wm', 'iconphoto', self.root._w, imgicon)
        self.root.geometry('{}x{}'.format(self.width, self.height))
        self.root.report_callback_exception = self.report_callback_exception

        self.frame = tk.Frame(self.root, borderwidth=0, relief="flat")
        self._mkwidget_filter()
        self._mkwidget_output(console_lines)
        self._mkwidget_results()

        self.frame.grid_rowconfigure(0, weight=0)
        self.frame.grid_rowconfigure(1, weight=0)
        self.frame.grid_rowconfigure(2, weight=0)
        self.frame.grid_rowconfigure(3, weight=1)
        self.frame.grid_columnconfigure(0, weight=1)

        self.set_entries("")

        self.root.bind("<Escape>", self.quit)
        self.filter.bind("<Up>", self._results_cursor_up)
        self.filter.bind("<Control-k>", self._results_cursor_up)
        self.filter.bind("<Down>", self._results_cursor_down)
        self.filter.bind("<Control-j>", self._results_cursor_down)
        self.filter.bind("<Return>", self._results_activate)
        self.results.bind("<Return>", self._results_activate)
        self.results.bind('<Double-1>', self._results_activate)

        self.frame.pack(side="top", fill="both", expand=True)
        self.root.mainloop()

    def _mkwidget_filter(self):
        self.filter_value = tk.StringVar()
        self.filter_value.trace("w", lambda name, index, mode: self._input_activate())
        self.filter = tk.Entry(self.frame, textvariable=self.filter_value,
                               font=("Sans", 12), bg="gray15", fg="white",
                               relief="flat", bd=8, insertbackground="white")
        self.filter.grid(row=0, columnspan=2, sticky="ew")
        self.filter.focus()

    def _mkwidget_output(self, console_lines=6):
        self.output_scrbr_x = AutoScrollbar(self.frame, orient="horizontal")
        self.output_scrbr_y = tk.Scrollbar(self.frame, orient="vertical")
        self.output = tk.Text(self.frame, width=20, height=console_lines,
                              wrap="none", borderwidth=8, highlightthickness=0,
                              bg="black", fg="white", bd=8, relief="flat",
                              xscrollcommand=self.output_scrbr_x.set,
                              yscrollcommand=self.output_scrbr_y.set)
        self.output_scrbr_x.config(command=self.output.xview)
        self.output_scrbr_y.config(command=self.output.yview)

    def _mkwidget_results(self):
        self.results = tk.Listbox(self.frame, selectmode=tk.BROWSE,
                                  font=("Sans", 12), bd=8, relief=tk.FLAT,
                                  exportselection=0)
        self.results_scrbr = tk.Scrollbar(self.frame, orient="vertical",
                                          command=self.results.yview)
        self.results.configure(yscrollcommand=self.results_scrbr.set)
        self.results.grid(row=3, column=0, sticky="nsew")
        self.results_scrbr.grid(row=3, column=1, sticky="ns")

    def _get_icon_path(self):
        """
        Return absolute path to icon, derefenced from the location of this
        'binary'.
        """
        if os.path.islink(sys.argv[0]):
            bin_path = os.readlink(sys.argv[0])
        else:
            bin_path = sys.argv[0]

        path = '{}/icon.png'.format(
            os.path.realpath(os.path.dirname(bin_path))
        )
        return path

    def _input_activate(self):
        """
        When the input field is activcated (enter or double click), perform the
        action under the cursor.
        """
        filter_value = self.filter_value.get()
        self.set_entries(self.filter_value.get())

    def set_entries(self, text):
        """
        Update the list of entries in Lurch and fuzzy-filter the entries based
        on what the user typed so far.
        """
        self.results.delete(0, tk.END)

        match_entries = self.entries
        if text != "":
            # Filter entries
            parts = text.lower().split(' ')
            for part in parts:
                match_entries = [
                    entry for entry in match_entries
                    if part in entry["title"].lower() or
                       entry.get("always", False) is True
                ]

        for entry in match_entries:
            self.results.insert(tk.END, entry["title"])

        # Activate first item
        if not self.results.curselection():
            self.results.activate(0)
            self.results.selection_set(0)

    def _results_activate(self, event):
        try:
            try:
                cursel = self.results.curselection()[0]
            except IndexError:
                return
            cur_item = self.results.get(cursel)
            filter = self.filter.get()
            entry_search = cur_item

            for entry in self.cur_entries:
                if entry["title"] == entry_search:
                    method = do_mapper[entry['type']]
                    method(self, filter, entry)
        except Exception as err:
            raise

    def _results_move_cur(self, i):
        """
        Move the entries cursor.
        """
        self.results.activate(i)
        self.results.selection_clear(0, tk.END)
        self.results.selection_set(i)
        self.results.see(i)

    def _results_cursor_up(self, event):
        """
        Move result pane cursor one up. Wrap around if top is hit.
        """
        cursel = self.results.curselection()[0]
        if cursel == 0:
            self._results_move_cur(tk.END)
            return "break"
        else:
            self._results_move_cur(cursel - 1)

    def _results_cursor_down(self, event):
        """
        Move result pane cursor one down. Wrap around if bottom is hit.
        """
        cursel = self.results.curselection()[0]
        end = len(self.results.get(0, tk.END))
        if cursel == end - 1:
            self._results_move_cur(0)
            return "break"
        else:
            self._results_move_cur(cursel + 1)

    def win_hide(self):
        """
        Hide the window.
        """
        self.root.withdraw()
        self.visible = False

    def quit(self, event=None):
        self.root.quit()

    def append_console_output(self, output):
        """
        Append lines to the inline "console".
        """
        # If we already sent some output to the inline console, add an empty
        # line before the new contents.
        output_text = self.output.get(1.0, tkinter.END)
        if len(output_text) > 1:
            self.output.insert(tkinter.END, "\n\n")

        self.output.insert(tkinter.END, output.rstrip())

        # Scroll to end
        self.output.see(tkinter.END)

        # Show the inline console, in case it was hidden.
        self.output_scrbr_y.grid(row=1, column=1, sticky="ns")
        self.output_scrbr_x.grid(row=2, column=0, sticky="we")
        self.output.grid(row=1, column=0, sticky="nsew")

    def report_callback_exception(self, *args):
        """
        Show thrown exceptions in tkinter's main loop in a dialog
        """
        err = traceback.format_exception(*args)
        tkinter.messagebox.showerror('Exception', str(args[1]))
        raise

def read_entries(lines):
    """
    Parse `lines` (stdin, usually) into actual entries that lurch can use.
    Entries are separated with two newlines in `lines` (a.k.a. one empty line).
    """
    bool_keys = ("shell", "always", "output_win", "output_inline", "clear_input")
    required_keys = ("type", "title", "value")
    entries = []
    cur_entry = {}
    for line in lines:
        line = line.strip()
        try:
            if line == "":
                # End of current entry. Make sure the user has specified all
                # required keys
                assert(all([key in cur_entry for key in required_keys]))
                entries.append(cur_entry)
                cur_entry = {}
            else:
                # Additional key/value for current entry.
                key, value = [part.strip() for part in line.split(":", 1)]
                if key in bool_keys:
                    cur_entry[key] = {"true": True, "false": False}[value.lower()]
                else:
                    cur_entry[key] = value
        except Exception as err:
            raise

    # Add last entry, unless input ends with empty line
    if cur_entry:
        assert(all([key in cur_entry for key in required_keys]))
        entries.append(cur_entry)

    return entries

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--width', metavar='WIDTH', dest='width', type=int, default=500)
    parser.add_argument('--height', metavar='HEIGHT', dest='height', type=int, default=600)
    parser.add_argument('--console-lines', metavar='CONSOLE_LINES', dest='console_lines', type=int, default=6)
    args = parser.parse_args()

    gui = GUI(args.width, args.height, args.console_lines, read_entries(sys.stdin.readlines()))
